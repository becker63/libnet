# ===========================================================================
# ðŸ§© nftnl "limit" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32

# ---------------------------------------------------------------------------
# Attribute IDs (mirroring libnftnl limit_attr_policy)
# ---------------------------------------------------------------------------
const
  idLimitRate* = uint16(NFTNL_EXPR_LIMIT_RATE)
  idLimitUnit* = uint16(NFTNL_EXPR_LIMIT_UNIT)
  idLimitBurst* = uint16(NFTNL_EXPR_LIMIT_BURST)
  idLimitType* = uint16(NFTNL_EXPR_LIMIT_TYPE)
  idLimitFlags* = uint16(NFTNL_EXPR_LIMIT_FLAGS)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc rate*(e: LimitExpr): uint32 =
  ## Base rate (packets or bytes per unit)
  getU32(toRaw(e), idLimitRate)

proc `rate=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitRate, v)

proc unit*(e: LimitExpr): uint32 =
  ## Unit interval (e.g., per second)
  getU32(toRaw(e), idLimitUnit)

proc `unit=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitUnit, v)

proc burst*(e: LimitExpr): uint32 =
  ## Allowed burst (number of packets/bytes exceeding rate)
  getU32(toRaw(e), idLimitBurst)

proc `burst=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitBurst, v)

proc limitType*(e: LimitExpr): uint32 =
  ## Type (NFT_LIMIT_PKT or NFT_LIMIT_BYTE)
  getU32(toRaw(e), idLimitType)

proc `limitType=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitType, v)

proc flags*(e: LimitExpr): uint32 =
  ## Flags (NFT_LIMIT_F_INV, etc.)
  getU32(toRaw(e), idLimitFlags)

proc `flags=`*(e: LimitExpr, v: uint32) =
  setU32(toRaw(e), idLimitFlags, v)
