# ===========================================================================
# ðŸ§© nftnl "immediate" expression attribute accessors
# ===========================================================================

import ../../autogenerated/generated_nftnl
import ../../raii/expresions
import ./all # getU32, setU32, getBlob, setBlob, getStr, setStr

# ---------------------------------------------------------------------------
# Attribute IDs
# ---------------------------------------------------------------------------
const
  idImmDreg* = uint16(NFTNL_EXPR_IMM_DREG)
  idImmData* = uint16(NFTNL_EXPR_IMM_DATA)
  idImmVerdict* = uint16(NFTNL_EXPR_IMM_VERDICT)
  idImmChain* = uint16(NFTNL_EXPR_IMM_CHAIN)
  idImmChainId* = uint16(NFTNL_EXPR_IMM_CHAIN_ID)

# ---------------------------------------------------------------------------
# Ergonomic field-like accessors
# ---------------------------------------------------------------------------

proc dreg*(e: ImmediateExpr): uint32 =
  ## Destination register to load the immediate value into.
  getU32(toRaw(e), idImmDreg)

proc `dreg=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmDreg, v)

proc data*(e: ImmediateExpr): seq[uint8] =
  ## Constant byte data for the immediate expression.
  getBlob(toRaw(e), idImmData)

proc `data=`*(e: ImmediateExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idImmData, v)

proc verdict*(e: ImmediateExpr): uint32 =
  ## Numeric verdict (NF_ACCEPT, NF_DROP, NF_JUMP, etc.)
  getU32(toRaw(e), idImmVerdict)

proc `verdict=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmVerdict, v)

proc chain*(e: ImmediateExpr): string =
  ## Optional chain name (used when verdict == NF_JUMP / NF_GOTO).
  getStr(toRaw(e), idImmChain)

proc `chain=`*(e: ImmediateExpr, v: string) =
  setStr(toRaw(e), idImmChain, v)

proc chainId*(e: ImmediateExpr): uint32 =
  ## Optional chain ID, used internally by nftables.
  getU32(toRaw(e), idImmChainId)

proc `chainId=`*(e: ImmediateExpr, v: uint32) =
  setU32(toRaw(e), idImmChainId, v)
