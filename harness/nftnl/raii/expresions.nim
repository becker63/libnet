{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

# ===========================================================================
# ðŸ§© Generic Expression RAII wrapper
# ===========================================================================

type Expression* = object
  raw*: ptr struct_nftnl_expr

# ---------------------------------------------------------------------------
# Lifecycle management
# ---------------------------------------------------------------------------

proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

# ===========================================================================
# ðŸ§© Strongly-typed variants (only the ones weâ€™ll support)
# ===========================================================================

type
  PayloadExpr* = distinct Expression
  CmpExpr* = distinct Expression
  MetaExpr* = distinct Expression
  BitwiseExpr* = distinct Expression
  ImmediateExpr* = distinct Expression
  CounterExpr* = distinct Expression
  CtExpr* = distinct Expression
  LimitExpr* = distinct Expression
  QuotaExpr* = distinct Expression

# ---------------------------------------------------------------------------
# Constructors enforce correct nftnl kind
# ---------------------------------------------------------------------------

proc create*(_: type PayloadExpr): PayloadExpr =
  PayloadExpr(Expression.create("payload"))

proc create*(_: type CmpExpr): CmpExpr =
  CmpExpr(Expression.create("cmp"))

proc create*(_: type MetaExpr): MetaExpr =
  MetaExpr(Expression.create("meta"))

proc create*(_: type BitwiseExpr): BitwiseExpr =
  BitwiseExpr(Expression.create("bitwise"))

proc create*(_: type ImmediateExpr): ImmediateExpr =
  ImmediateExpr(Expression.create("immediate"))

proc create*(_: type CounterExpr): CounterExpr =
  CounterExpr(Expression.create("counter"))

proc create*(_: type CtExpr): CtExpr =
  CtExpr(Expression.create("ct"))

proc create*(_: type LimitExpr): LimitExpr =
  LimitExpr(Expression.create("limit"))

proc create*(_: type QuotaExpr): QuotaExpr =
  QuotaExpr(Expression.create("quota"))

# ===========================================================================
# ðŸª„ Implicit converters
# ===========================================================================

converter toExpression*(e: sink PayloadExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CmpExpr): Expression =
  Expression(e)

converter toExpression*(e: sink MetaExpr): Expression =
  Expression(e)

converter toExpression*(e: sink BitwiseExpr): Expression =
  Expression(e)

converter toExpression*(e: sink ImmediateExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CounterExpr): Expression =
  Expression(e)

converter toExpression*(e: sink CtExpr): Expression =
  Expression(e)

converter toExpression*(e: sink LimitExpr): Expression =
  Expression(e)

converter toExpression*(e: sink QuotaExpr): Expression =
  Expression(e)

# ===========================================================================
# ðŸ”§ Generic raw() / toRaw() accessors
# ===========================================================================

template raw*(e: typed): ptr struct_nftnl_expr =
  when e is Expression:
    e.raw
  else:
    Expression(e).raw

template toRaw*(e: typed): ptr struct_nftnl_expr =
  when e is Expression:
    e.raw
  else:
    Expression(e).raw
