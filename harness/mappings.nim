# Keep the same import style/ordering as your working modules
import proto_raw as pbraw

# Low-level bindings (names only needed to satisfy transitive inline procs)
import nftnl/autogenerated/generated_nftnl as gen_nftnl
import linux/autogenerated/generated_linux as gen_linux

# RAII + attrs layers (exact modules you use in tests)
import nftnl/raii/[basics, expresions]
import nftnl/attrs/rule as ar
import nftnl/attrs/chain as ac
import nftnl/attrs/table as at
import nftnl/attrs/expr/[all, cmp, payload]
import messageBuilder

# ──────────────────────────────────────────────────────────────
# Debug helper
# ──────────────────────────────────────────────────────────────
when defined(DEBUG_MAPPING):
  proc dbg(msg: string) =
    echo msg

else:
  template dbg(msg: string) =
    discard

# ──────────────────────────────────────────────────────────────
# Small byte helpers
# ──────────────────────────────────────────────────────────────
proc toU32Le*(b: openArray[uint8]): uint32 =
  case b.len
  of 0:
    0'u32
  of 1:
    uint32(b[0])
  of 2:
    uint32(b[0]) or (uint32(b[1]) shl 8)
  else:
    uint32(b[0]) or (uint32(b[1]) shl 8) or (uint32(b[2]) shl 16) or
      (uint32(b[3]) shl 24)

proc toU64Le*(b: openArray[uint8]): uint64 =
  var res: uint64 = 0
  for i in 0 ..< min(b.len, 8):
    res = res or (uint64(b[i]) shl (i * 8))
  res

proc bytesToStr*(b: seq[uint8]): string =
  if b.len == 0:
    return ""
  result = newString(b.len)
  for i in 0 ..< b.len:
    result[i] = char(b[i])

# ──────────────────────────────────────────────────────────────
# Expression conversion (uses your RAII + attr helpers)
# ──────────────────────────────────────────────────────────────
proc toNftnlExpr*(x: pbraw.Expr): expresions.Expression =
  var e: expresions.Expression
  case x.`type`
  of 1'u32:
    e = expresions.Expression(expresions.PayloadExpr.create())
    let p = x.payload
    setU32(toRaw(e), payload.idPayloadDreg, p.dreg)
    setU32(toRaw(e), payload.idPayloadBase, p.base)
    setU32(toRaw(e), payload.idPayloadOffset, p.offset)
    setU32(toRaw(e), payload.idPayloadLen, p.len)
  of 2'u32:
    e = expresions.Expression(expresions.CmpExpr.create())
    let c = x.cmp
    setU32(toRaw(e), cmp.idCmpSreg, c.sreg)
    setU32(toRaw(e), cmp.idCmpOp, c.op)
    if c.data.len > 0:
      setBlob(toRaw(e), cmp.idCmpData, c.data)
  else:
    dbg "      [warn] unknown expr type=" & $x.`type`
    return expresions.Expression()
  e

# ──────────────────────────────────────────────────────────────
# Rule / Chain / Table mapping (PROPERTY ASSIGNMENT, not proc calls)
# ──────────────────────────────────────────────────────────────
proc toNftnlRule*(x: pbraw.Rule): basics.Rule =
  let r = basics.Rule.create()
  r.family = x.family
  r.table = x.table
  r.chain = x.chain
  dbg "    → Rule(family=" & $x.family & ", table=" & x.table & ", chain=" & x.chain &
    ")"
  for ex in x.exprs:
    let e = toNftnlExpr(ex)
    if e.raw.isNil:
      dbg "      [skip] invalid expr; not adding"
      continue
    addExpr(r, e)
  r

proc toNftnlChain*(x: pbraw.Chain): basics.Chain =
  let c = basics.Chain.create()
  c.family = x.family
  c.table = x.table
  c.name = x.name
  dbg "  → Chain(" & x.name & ") table=" & x.table
  for r in x.rules:
    discard toNftnlRule(r)
  c

proc toNftnlTable*(x: pbraw.Table): basics.Table =
  let t = basics.Table.create()
  t.family = x.family
  t.name = x.name
  dbg "→ Table(" & x.name & ") family=" & $x.family
  for ch in x.chains:
    discard toNftnlChain(ch)
  t

# ──────────────────────────────────────────────────────────────
# ⚙️  Serialization helpers (use only newNlMsg + build*Msg)
# ──────────────────────────────────────────────────────────────
const
  NFT_MSG_NEWTABLE* = 0x10'u32
  NFT_MSG_NEWCHAIN* = 0x11'u32
  NFT_MSG_NEWRULE* = 0x12'u32
  NLM_F_CREATE* = 0x400'u32
  NLM_F_EXCL* = 0x200'u32
  NLM_F_ACK* = 0x4'u32

proc serializeTableWithNewNlMsg*(t: basics.Table, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWTABLE.cint,
    t.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildTableMsg(nlh, t)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)

proc serializeChainWithNewNlMsg*(c: basics.Chain, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWCHAIN.cint,
    c.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildChainMsg(nlh, c)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)

proc serializeRuleWithNewNlMsg*(r: basics.Rule, seqNum: uint32): seq[uint8] =
  let nlh = newNlMsg(
    NFT_MSG_NEWRULE.cint,
    r.family.cint,
    (NLM_F_CREATE or NLM_F_EXCL or NLM_F_ACK).cint,
    seqNum,
  )
  buildRuleMsg(nlh, r)
  result = cast[seq[uint8]](cast[ptr UncheckedArray[uint8]](nlh))
  result.setLen(MNL_SOCKET_BUFFER_SIZE)

# ---------------------------------------------------------------------
# buildTop: walks Top and calls the serialization helpers
# ---------------------------------------------------------------------
proc buildTop*(x: pbraw.Top): seq[seq[uint8]] =
  result = @[]
  var seqNum: uint32 = 1
  for tpb in x.tables:
    let t = toNftnlTable(tpb)
    result.add serializeTableWithNewNlMsg(t, seqNum)
    seqNum.inc
    for cpb in tpb.chains:
      let c = toNftnlChain(cpb)
      result.add serializeChainWithNewNlMsg(c, seqNum)
      seqNum.inc
      for rpb in cpb.rules:
        let r = toNftnlRule(rpb)
        result.add serializeRuleWithNewNlMsg(r, seqNum)
        seqNum.inc
