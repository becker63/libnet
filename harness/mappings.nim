# Keep the same import style/ordering as your working modules
import proto_raw as pbraw

# Low-level bindings (names only needed to satisfy transitive inline procs)
import nftnl/autogenerated/generated_nftnl as gen_nftnl
import linux/autogenerated/generated_linux as gen_linux

# RAII + attrs layers (exact modules you use in tests)
import nftnl/raii/[basics, expresions]
import nftnl/attrs/rule as ar
import nftnl/attrs/chain as ac
import nftnl/attrs/table as at
import nftnl/attrs/expr/[all, cmp, payload]
import messageBuilder

# ──────────────────────────────────────────────────────────────
# Debug helper
# ──────────────────────────────────────────────────────────────
when defined(DEBUG_MAPPING):
  proc dbg(msg: string) =
    echo msg

else:
  template dbg(msg: string) =
    discard

# ──────────────────────────────────────────────────────────────
# Small byte helpers (kept because they’re handy elsewhere)
# ──────────────────────────────────────────────────────────────
proc toU32Le*(b: openArray[uint8]): uint32 =
  case b.len
  of 0:
    0'u32
  of 1:
    uint32(b[0])
  of 2:
    uint32(b[0]) or (uint32(b[1]) shl 8)
  else:
    uint32(b[0]) or (uint32(b[1]) shl 8) or (uint32(b[2]) shl 16) or
      (uint32(b[3]) shl 24)

proc toU64Le*(b: openArray[uint8]): uint64 =
  var res: uint64 = 0
  for i in 0 ..< min(b.len, 8):
    res = res or (uint64(b[i]) shl (i * 8))
  res

proc bytesToStr*(b: seq[uint8]): string =
  if b.len == 0:
    return ""
  result = newString(b.len)
  for i in 0 ..< b.len:
    result[i] = char(b[i])

# ──────────────────────────────────────────────────────────────
# Expression conversion (uses your RAII + attr helpers)
# ──────────────────────────────────────────────────────────────
proc toNftnlExpr*(x: pbraw.Expr): expresions.Expression =
  var e: expresions.Expression
  case x.`type`
  of 1'u32:
    # payload
    e = expresions.Expression(expresions.PayloadExpr.create())
    let p = x.payload
    setU32(toRaw(e), payload.idPayloadDreg, p.dreg)
    setU32(toRaw(e), payload.idPayloadBase, p.base) # already uint32
    setU32(toRaw(e), payload.idPayloadOffset, p.offset)
    setU32(toRaw(e), payload.idPayloadLen, p.len)
  of 2'u32:
    # cmp
    e = expresions.Expression(expresions.CmpExpr.create())
    let c = x.cmp
    setU32(toRaw(e), cmp.idCmpSreg, c.sreg)
    setU32(toRaw(e), cmp.idCmpOp, c.op) # already uint32
    if c.data.len > 0:
      setBlob(toRaw(e), cmp.idCmpData, c.data)
  else:
    dbg "      [warn] unknown expr type=" & $x.`type`
    return expresions.Expression()
  e

# ──────────────────────────────────────────────────────────────
# Rule / Chain / Table mapping (PROPERTY ASSIGNMENT, not proc calls)
# ──────────────────────────────────────────────────────────────
proc toNftnlRule*(x: pbraw.Rule): basics.Rule =
  let r = basics.Rule.create()
  r.family = x.family
  r.table = x.table
  r.chain = x.chain
  dbg "    → Rule(family=" & $x.family & ", table=" & x.table & ", chain=" & x.chain &
    ")"
  for ex in x.exprs:
    let e = toNftnlExpr(ex)
    if e.raw.isNil:
      dbg "      [skip] invalid expr; not adding"
      continue
    addExpr(r, e)
  r

proc toNftnlChain*(x: pbraw.Chain): basics.Chain =
  let c = basics.Chain.create()
  c.family = x.family
  c.table = x.table
  c.name = x.name
  # You can add the rest (type/hook/prio/policy) once their props exist
  dbg "  → Chain(" & x.name & ") table=" & x.table
  for r in x.rules:
    discard toNftnlRule(r)
  c

proc toNftnlTable*(x: pbraw.Table): basics.Table =
  let t = basics.Table.create()
  t.family = x.family
  t.name = x.name
  dbg "→ Table(" & x.name & ") family=" & $x.family
  for ch in x.chains:
    discard toNftnlChain(ch)
  t

proc buildTop*(x: pbraw.Top) =
  for t in x.tables:
    discard toNftnlTable(t)
