import ./mnl/autogenerated/generated_mnl as mnl
import ./nftnl/autogenerated/generated_nftnl as nftnl
import ./nftnl/raii/basics
import ./linux/autogenerated/generated_linux as linux

# Alias to avoid ambiguous struct names
type NlMsgHdr* = nftnl.struct_nlmsghdr

# https://www.netfilter.org/projects/libmnl/doxygen/html/group__socket.html#ga69e37f7eb857be032a0f4afc7bd83ce9
# MNL_SOCKET_BUFFER_SIZE (which is 8KB, see linux/netlink.h for more information).
const MNL_SOCKET_BUFFER_SIZE* = 8 * 1024

proc newNlMsg*(msgType: cint, family: cint, flags: cint, seq: uint32): ptr NlMsgHdr =
  ## Allocate a userland buffer and initialize a netlink message header
  let buf = cast[ptr uint8](alloc0(MNL_SOCKET_BUFFER_SIZE))
  result =
    nftnl.nftnl_nlmsg_build_hdr(buf, msgType.uint16, family.uint16, flags.uint16, seq)
  if result.isNil:
    raise newException(OSError, "Failed to build nlmsghdr")

proc buildTableMsg*(nlh: ptr NlMsgHdr, t: Table) =
  nftnl.nftnl_table_nlmsg_build_payload(nlh, t.raw)

proc buildChainMsg*(nlh: ptr NlMsgHdr, c: Chain) =
  nftnl.nftnl_chain_nlmsg_build_payload(nlh, c.raw)

proc buildRuleMsg*(nlh: ptr NlMsgHdr, r: Rule) =
  nftnl.nftnl_rule_nlmsg_build_payload(nlh, r.raw)

proc addExpr*(r: Rule, e: sink Expression) =
  nftnl_rule_add_expr(r.raw, e.raw)
  e.raw = nil # hand off ownership to libnftnl
