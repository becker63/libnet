{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

# Base expression type (already in basics.nim)
type Expression* = object
  raw*: ptr struct_nftnl_expr

# RAII lifecycle for generic Expression
proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

proc kind*(e: Expression): string =
  if e.raw == nil:
    return ""
  $cast[cstring](nftnl_expr_get_str(e.raw, NFTNL_EXPR_NAME.uint16))

# --- Typed variants ----------------------------------------------------------

type
  CmpExpr* = distinct Expression
  PayloadExpr* = distinct Expression
  MetaExpr* = distinct Expression

# Constructors enforce kind at compile time
proc create*(_: type CmpExpr): CmpExpr =
  CmpExpr(Expression.create("cmp"))

proc create*(_: type PayloadExpr): PayloadExpr =
  PayloadExpr(Expression.create("payload"))

proc create*(_: type MetaExpr): MetaExpr =
  MetaExpr(Expression.create("meta"))

# Access to underlying raw
proc raw*(e: CmpExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw

proc raw*(e: PayloadExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw

proc raw*(e: MetaExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw
