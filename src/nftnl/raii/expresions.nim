{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

type Expression* = object
  raw*: ptr struct_nftnl_expr

# ---------------------------------------------------------------------------
# ðŸ§© RAII lifecycle for generic Expression
# ---------------------------------------------------------------------------
proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

proc kind*(e: Expression): string =
  if e.raw == nil:
    return ""
  $cast[cstring](nftnl_expr_get_str(e.raw, NFTNL_EXPR_NAME.uint16))

# ---------------------------------------------------------------------------
# ðŸ§© Typed variants (CmpExpr, PayloadExpr, MetaExpr)
# ---------------------------------------------------------------------------
type
  CmpExpr* = distinct Expression
  PayloadExpr* = distinct Expression
  MetaExpr* = distinct Expression

# Constructors enforce kind at compile time
proc create*(_: type CmpExpr): CmpExpr =
  CmpExpr(Expression.create("cmp"))

proc create*(_: type PayloadExpr): PayloadExpr =
  PayloadExpr(Expression.create("payload"))

proc create*(_: type MetaExpr): MetaExpr =
  MetaExpr(Expression.create("meta"))

template raw*(e: typed): ptr struct_nftnl_expr =
  ## Direct access to the underlying nftnl expression pointer.
  when e is Expression:
    e.raw
  else:
    Expression(e).raw

template toRaw*(e: typed): ptr struct_nftnl_expr =
  ## Alias for raw(e); kept for readability and API parity.
  when e is Expression:
    e.raw
  else:
    Expression(e).raw
