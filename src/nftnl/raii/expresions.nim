{.push sinkInference: on.}

import ../../deriveables/deriveables
import ../autogenerated/generated_nftnl

# ---------------------------------------------------------------------------
# ðŸ§± Base expression type
# ---------------------------------------------------------------------------
type Expression* = object
  raw*: ptr struct_nftnl_expr

# ---------------------------------------------------------------------------
# ðŸ§© RAII lifecycle for generic Expression
# ---------------------------------------------------------------------------
proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

proc kind*(e: Expression): string =
  if e.raw == nil:
    return ""
  $cast[cstring](nftnl_expr_get_str(e.raw, NFTNL_EXPR_NAME.uint16))

# ---------------------------------------------------------------------------
# ðŸ§© Typed variants (CmpExpr, PayloadExpr, MetaExpr)
# ---------------------------------------------------------------------------
type
  CmpExpr* = distinct Expression
  PayloadExpr* = distinct Expression
  MetaExpr* = distinct Expression

# Constructors enforce kind at compile time
proc create*(_: type CmpExpr): CmpExpr =
  CmpExpr(Expression.create("cmp"))

proc create*(_: type PayloadExpr): PayloadExpr =
  PayloadExpr(Expression.create("payload"))

proc create*(_: type MetaExpr): MetaExpr =
  MetaExpr(Expression.create("meta"))

# Access to underlying raw (simple field view)
proc raw*(e: CmpExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw

proc raw*(e: PayloadExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw

proc raw*(e: MetaExpr): ptr struct_nftnl_expr {.inline.} =
  Expression(e).raw

# ---------------------------------------------------------------------------
# ðŸ§© Deriveables bridges
# ---------------------------------------------------------------------------
# These form the compile-time graph that lets `deriveables` resolve
# how to convert between RAII and C-layer types.

# Base bridge
proc toRaw*(e: Expression): ptr struct_nftnl_expr {.deriveable.} =
  e.raw

# Subtype â†’ Expression bridge
proc toExpression*[T: CmpExpr | PayloadExpr | MetaExpr](
    e: T
): Expression {.deriveable.} =
  Expression(e)

# Subtype â†’ raw bridge (NO deriveable pragma!)
proc toRaw*(e: CmpExpr): ptr struct_nftnl_expr =
  toRaw(Expression(e))

proc toRaw*(e: PayloadExpr): ptr struct_nftnl_expr =
  toRaw(Expression(e))

proc toRaw*(e: MetaExpr): ptr struct_nftnl_expr =
  toRaw(Expression(e))
