{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

template makeWrapper(typeName, structName, allocFn, freeFn: untyped) =
  type `typeName`* = object
    raw*: ptr `structName`

  proc create*(_: type `typeName`): `typeName` =
    `typeName`(raw: allocFn())

  proc `=destroy`*(x: var `typeName`) =
    if x.raw != nil:
      freeFn(x.raw)
      x.raw = nil

  proc `=wasMoved`*(x: var `typeName`) =
    x.raw = nil

  proc `=copy`*(dst: var `typeName`, src: `typeName`) {.error.}

  proc `=sink`*(dst: var `typeName`, src: `typeName`) =
    if dst.raw == src.raw:
      return
    `=destroy`(dst)
    dst.raw = src.raw
    var tmp = src
    `=wasMoved`(tmp)

  proc raw*(x: `typeName`): ptr `structName` {.inline.} =
    x.raw

# --- concrete wrappers -----------------------------------------------------
makeWrapper(Table, struct_nftnl_table, nftnl_table_alloc, nftnl_table_free)
makeWrapper(Chain, struct_nftnl_chain, nftnl_chain_alloc, nftnl_chain_free)
makeWrapper(Rule, struct_nftnl_rule, nftnl_rule_alloc, nftnl_rule_free)
makeWrapper(Set, struct_nftnl_set, nftnl_set_alloc, nftnl_set_free)
makeWrapper(
  TableList, struct_nftnl_table_list, nftnl_table_list_alloc, nftnl_table_list_free
)
makeWrapper(
  ChainList, struct_nftnl_chain_list, nftnl_chain_list_alloc, nftnl_chain_list_free
)
makeWrapper(
  RuleList, struct_nftnl_rule_list, nftnl_rule_list_alloc, nftnl_rule_list_free
)
makeWrapper(SetList, struct_nftnl_set_list, nftnl_set_list_alloc, nftnl_set_list_free)
makeWrapper(SetElem, struct_nftnl_set_elem, nftnl_set_elem_alloc, nftnl_set_elem_free)

# --- Expression ------------------------------------------------------------
type Expression* = object
  raw*: ptr struct_nftnl_expr

proc create*(_: type Expression, kind: string): Expression =
  Expression(raw: nftnl_expr_alloc(cast[ptr uint8](kind.cstring)))

proc `=destroy`*(x: var Expression) =
  if x.raw != nil:
    nftnl_expr_free(x.raw)
    x.raw = nil

proc `=wasMoved`*(x: var Expression) =
  x.raw = nil

proc `=copy`*(dst: var Expression, src: Expression) {.error.}

proc `=sink`*(dst: var Expression, src: Expression) =
  if dst.raw == src.raw:
    return
  `=destroy`(dst)
  dst.raw = src.raw
  var tmp = src
  `=wasMoved`(tmp)

proc raw*(e: Expression): ptr struct_nftnl_expr {.inline.} =
  e.raw

proc kind*(e: Expression): string =
  if e.raw == nil:
    return ""
  $cast[cstring](nftnl_expr_get_str(e.raw, NFTNL_EXPR_NAME.uint16))

proc addExpr*(r: Rule, e: sink Expression) =
  nftnl_rule_add_expr(r.raw, e.raw)
