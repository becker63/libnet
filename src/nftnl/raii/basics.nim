{.push sinkInference: on.}

import ../autogenerated/generated_nftnl

template makeWrapper(typeName, structName, allocFn, freeFn: untyped) =
  type `typeName`* = object
    raw*: ptr `structName`

  proc create*(_: type `typeName`): `typeName` =
    `typeName`(raw: allocFn())

  proc `=destroy`*(x: var `typeName`) =
    if x.raw != nil:
      freeFn(x.raw)
      x.raw = nil

  proc `=wasMoved`*(x: var `typeName`) =
    x.raw = nil

  proc `=copy`*(dst: var `typeName`, src: `typeName`) {.error.}

  proc `=sink`*(dst: var `typeName`, src: `typeName`) =
    if dst.raw == src.raw:
      return
    `=destroy`(dst)
    dst.raw = src.raw

  proc raw*(x: `typeName`): ptr `structName` {.inline.} =
    x.raw

# --- concrete wrappers -----------------------------------------------------
makeWrapper(Table, struct_nftnl_table, nftnl_table_alloc, nftnl_table_free)
makeWrapper(Chain, struct_nftnl_chain, nftnl_chain_alloc, nftnl_chain_free)
makeWrapper(Rule, struct_nftnl_rule, nftnl_rule_alloc, nftnl_rule_free)
makeWrapper(Set, struct_nftnl_set, nftnl_set_alloc, nftnl_set_free)
makeWrapper(
  TableList, struct_nftnl_table_list, nftnl_table_list_alloc, nftnl_table_list_free
)
makeWrapper(
  ChainList, struct_nftnl_chain_list, nftnl_chain_list_alloc, nftnl_chain_list_free
)
makeWrapper(
  RuleList, struct_nftnl_rule_list, nftnl_rule_list_alloc, nftnl_rule_list_free
)
makeWrapper(SetList, struct_nftnl_set_list, nftnl_set_list_alloc, nftnl_set_list_free)
makeWrapper(SetElem, struct_nftnl_set_elem, nftnl_set_elem_alloc, nftnl_set_elem_free)
