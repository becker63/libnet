# src/nftnl/iterators.nim
import ./autogenerated/generated_nftnl
import ./basics

#
# View types (non-owning)
# These just wrap raw pointers returned by libnftnl lists/iterators.
# They DO NOT free memory on destruction.
#
type
  TableView* = object
    raw*: ptr struct_nftnl_table

  ChainView* = object
    raw*: ptr struct_nftnl_chain

  RuleView* = object
    raw*: ptr struct_nftnl_rule

  SetView* = object
    raw*: ptr struct_nftnl_set

  SetElemView* = object
    raw*: ptr struct_nftnl_set_elem

#
# Generic iterator template
#
template defineIterator(
    iterName, viewType, listWrapType, itemType, createFn, nextFn, destroyFn: untyped
) =
  iterator `iterName`*(list: listWrapType): viewType =
    var it = createFn(list.raw)
    defer:
      destroyFn(it)

    var next: ptr itemType
    while true:
      next = nextFn(it)
      if next.isNil:
        break
      yield viewType(raw: next)

#
# Iterators
#

# For tables
defineIterator(
  tableIter, TableView, TableList, struct_nftnl_table, nftnl_table_list_iter_create,
  nftnl_table_list_iter_next, nftnl_table_list_iter_destroy,
)

# For chains
defineIterator(
  chainIter, ChainView, ChainList, struct_nftnl_chain, nftnl_chain_list_iter_create,
  nftnl_chain_list_iter_next, nftnl_chain_list_iter_destroy,
)

# For rules
defineIterator(
  ruleIter, RuleView, RuleList, struct_nftnl_rule, nftnl_rule_list_iter_create,
  nftnl_rule_list_iter_next, nftnl_rule_list_iter_destroy,
)

# For sets
defineIterator(
  setIter, SetView, SetList, struct_nftnl_set, nftnl_set_list_iter_create,
  nftnl_set_list_iter_next, nftnl_set_list_iter_destroy,
)

# For set elements (special API: cur/next)
iterator setElemIter*(s: SetView): SetElemView =
  var it = nftnl_set_elems_iter_create(s.raw)
  defer:
    nftnl_set_elems_iter_destroy(it)

  while true:
    let cur = nftnl_set_elems_iter_cur(it)
    if cur.isNil:
      break
    yield SetElemView(raw: cur)
    discard nftnl_set_elems_iter_next(it)
