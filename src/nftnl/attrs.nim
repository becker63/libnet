import ./autogenerated/generated_nftnl
import ./basics

# --- raw procs ---
proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: string) =
  discard nftnl_table_set_str(t, attr, cast[ptr uint8](v.cstring))

proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: uint32) =
  nftnl_table_set_u32(t, attr, v)

proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: uint64) =
  nftnl_table_set_u64(t, attr, v)

proc rawGetAttr*(t: ptr struct_nftnl_table, attr: uint16, _: typedesc[string]): string =
  $cast[cstring](nftnl_table_get_str(t, attr))

proc rawGetAttr*(t: ptr struct_nftnl_table, attr: uint16, _: typedesc[uint32]): uint32 =
  nftnl_table_get_u32(t, attr)

proc rawGetAttr*(t: ptr struct_nftnl_table, attr: uint16, _: typedesc[uint64]): uint64 =
  nftnl_table_get_u64(t, attr)

#[
  Nim’s compile-time world is Turing complete, but it’s a separate phase. That’s why we used AttrKind at runtime: to carry “type-like” information into the runtime world, where real typedescs no longer exist.

  This is basically a hack to match on these types we need so I dont have to dive into macros yet
]#
type AttrKind = enum
  akString
  akU32
  akU64

# TODO: Learn the macro magic to check this at comptime, its absolutely possible
# Need to make a mapping from these enums to supported types.. This is sadly just "tribal knowledge" in netfilter land so go read some tests and find some examples
proc expectedKind(attr: enum_nftnl_table_attr): AttrKind =
  case attr
  of NFTNL_TABLE_NAME:
    akString
  of NFTNL_TABLE_FAMILY:
    akU32
  of NFTNL_TABLE_FLAGS:
    akU32
  of NFTNL_TABLE_USE:
    akU32
  of NFTNL_TABLE_HANDLE:
    akU64
  of NFTNL_TABLE_USERDATA:
    akString
  of NFTNL_TABLE_OWNER:
    akString
  else:
    raise newException(ValueError, "Unsupported attribute: " & $attr)

# --- sugared procs with runtime checks ---
proc setAttr*(t: Table, attr: enum_nftnl_table_attr, v: string) =
  doAssert expectedKind(attr) == akString, "wrong type for " & $attr
  rawSetAttr(t.raw, attr.uint16, v)

proc setAttr*(t: Table, attr: enum_nftnl_table_attr, v: uint32) =
  doAssert expectedKind(attr) == akU32, "wrong type for " & $attr
  rawSetAttr(t.raw, attr.uint16, v)

proc setAttr*(t: Table, attr: enum_nftnl_table_attr, v: uint64) =
  doAssert expectedKind(attr) == akU64, "wrong type for " & $attr
  rawSetAttr(t.raw, attr.uint16, v)

proc getAttr*(t: Table, attr: enum_nftnl_table_attr, _: typedesc[string]): string =
  doAssert expectedKind(attr) == akString, "wrong type for " & $attr
  rawGetAttr(t.raw, attr.uint16, string)

proc getAttr*(t: Table, attr: enum_nftnl_table_attr, _: typedesc[uint32]): uint32 =
  doAssert expectedKind(attr) == akU32, "wrong type for " & $attr
  rawGetAttr(t.raw, attr.uint16, uint32)

proc getAttr*(t: Table, attr: enum_nftnl_table_attr, _: typedesc[uint64]): uint64 =
  doAssert expectedKind(attr) == akU64, "wrong type for " & $attr
  rawGetAttr(t.raw, attr.uint16, uint64)
