import ../../autogenerated/generated_nftnl
import ../../raii/expresions

# --- low-level raw ----------------------------------------------------------

proc getU32*(p: ptr struct_nftnl_expr, attr: uint16): uint32 =
  nftnl_expr_get_u32(p, attr)

proc getBlob*(p: ptr struct_nftnl_expr, attr: uint16): seq[uint8] =
  var size: uint32
  let data = nftnl_expr_get(p, attr, addr size)
  if data.isNil or size == 0:
    return @[]
  result = newSeq[uint8](int(size))
  copyMem(addr result[0], data, size)

proc setU32*(p: ptr struct_nftnl_expr, attr: uint16, v: uint32) =
  nftnl_expr_set_u32(p, attr, v)

proc setBlob*(p: ptr struct_nftnl_expr, attr: uint16, v: seq[uint8]) =
  if v.len > 0:
    discard nftnl_expr_set(p, attr, unsafeAddr v[0], uint32(v.len))
  else:
    discard nftnl_expr_set(p, attr, nil, 0)

# --- ids --------------------------------------------------------

const
  idCmpSreg* = uint16(NFTNL_EXPR_CMP_SREG)
  idCmpOp* = uint16(NFTNL_EXPR_CMP_OP)
  idCmpData* = uint16(NFTNL_EXPR_CMP_DATA)

# --- high-level bridges ----------------------------

proc getCmpSreg*(e: CmpExpr): uint32 =
  getU32(toRaw(e), idCmpSreg)

proc setCmpSreg*(e: CmpExpr, v: uint32) =
  setU32(toRaw(e), idCmpSreg, v)

proc getCmpOp*(e: CmpExpr): uint32 =
  getU32(toRaw(e), idCmpOp)

proc setCmpOp*(e: CmpExpr, v: uint32) =
  setU32(toRaw(e), idCmpOp, v)

proc getCmpData*(e: CmpExpr): seq[uint8] =
  getBlob(toRaw(e), idCmpData)

proc setCmpData*(e: CmpExpr, v: seq[uint8]) =
  setBlob(toRaw(e), idCmpData, v)
