import macros
import ../autogenerated/generated_nftnl
import ../basics

# --- raw API stays as-is ---
proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: string) =
  discard nftnl_table_set_str(t, attr, cast[ptr uint8](v.cstring))

proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: uint32) =
  nftnl_table_set_u32(t, attr, v)

proc rawSetAttr*(t: ptr struct_nftnl_table, attr: uint16, v: uint64) =
  nftnl_table_set_u64(t, attr, v)

proc rawGetAttr*[T](t: ptr struct_nftnl_table, attr: uint16, _: typedesc[T]): T =
  when T is string:
    # nftnl_table_get_str is declared in the bindings as returning `ptr uint8`,
    # but in the C API it is really a `const char*` (null-terminated string).
    #
    # We `$cast` it to Nim's `cstring` type to reinterpret the pointer correctly,
    # and then apply `$` to copy it into a managed Nim `string`.
    # This way we get a safe Nim string while the original buffer is still owned
    # by libnftnl.
    $cast[cstring](nftnl_table_get_str(t, attr))
  elif T is uint32:
    nftnl_table_get_u32(t, attr)
  elif T is uint64:
    nftnl_table_get_u64(t, attr)
  else:
    {.error: "Unsupported type for rawGetAttr".}

# --- helper: map attr -> Nim type at compile-time ---
#!fmt: off
# Expands directly to a type (`string`, `uint32`, `uint64`) at CT.
#
# Nim does not let you represent types as a literal set/array
# (e.g. [`string`, `uint32`, `uint64`]). If you return `typedesc`
# here, the compiler treats it as a runtime value, not a literal
# type symbol. `untyped` is required so the template substitutes
# the type itself into the call site.
template expectedType(attr: static enum_nftnl_table_attr): untyped =
  when attr in {
    NFTNL_TABLE_NAME,
    NFTNL_TABLE_USERDATA,
    NFTNL_TABLE_OWNER
  }:
    string

  elif attr in {
    NFTNL_TABLE_FAMILY,
    NFTNL_TABLE_FLAGS,
    NFTNL_TABLE_USE
  }:
    uint32

  elif attr in {
    NFTNL_TABLE_HANDLE
  }:
    uint64

  else:
    {.error: "Unsupported attribute: " & $attr.}
#!fmt: on

# --- single macro implementing both getter and setter ---
macro attrOp*(t: typed, attr: typed, args: varargs[untyped]): untyped =
  if args.len == 0:
    # Case: getter
    result = quote:
      # At the callsite this expands into something like:
      #   rawGetAttr[string](t.raw, attr.uint16, string)
      #
      # - `expectedType(attr)` expands to a literal type symbol
      #   (string, uint32, or uint64).
      # - That type is used both as the generic parameter to rawGetAttr[T]
      #   and as the final argument (the `typedesc[T]` overload selector).
      # - So if attr == NFTNL_TABLE_NAME, the expansion is exactly:
      #   rawGetAttr[string](t.raw, NFTNL_TABLE_NAME.uint16, string)
      rawGetAttr[expectedType(`attr`)](`t`.raw, `attr`.uint16, expectedType(`attr`))
  elif args.len == 1:
    # Case: setter
    result = quote:
      block:
        # At the callsite this expands into something like:
        #   block:
        #     let v: string = args[0]
        #     rawSetAttr(t.raw, attr.uint16, v)
        #
        # - `expectedType(attr)` again expands to a literal type.
        # - The `let v: Type = args[0]` ensures compile-time type checking:
        #   the provided value must be convertible to the expected type.
        # - Then `rawSetAttr` is called with the correctly typed value.
        let v: expectedType(`attr`) = `args [ 0 ]`
        rawSetAttr(`t`.raw, `attr`.uint16, v)
  else:
    error("attrOp takes 0 or 1 extra arguments", args[1])

# --- convenience wrappers ---
template setAttr*(t: Table, attr: enum_nftnl_table_attr, val: untyped): untyped =
  attrOp(t, attr, val)

template getAttr*(t: Table, attr: enum_nftnl_table_attr): untyped =
  attrOp(t, attr)
