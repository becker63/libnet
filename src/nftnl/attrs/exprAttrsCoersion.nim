import macros
import ../autogenerated/generated_nftnl
import ../contracts/expr
import ../raii/basics # for Expression type

# --- raw API ------------------------------------------------------

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: string) =
  discard nftnl_expr_set_str(e, attr, cast[ptr uint8](v.cstring))

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: uint8) =
  nftnl_expr_set_u8(e, attr, v)

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: uint16) =
  nftnl_expr_set_u16(e, attr, v)

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: uint32) =
  nftnl_expr_set_u32(e, attr, v)

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: uint64) =
  nftnl_expr_set_u64(e, attr, v)

proc rawSetAttr*(e: ptr struct_nftnl_expr, attr: uint16, v: seq[uint8]) =
  if v.len > 0:
    discard nftnl_expr_set(e, attr, unsafeAddr v[0], uint32(v.len))
  else:
    discard nftnl_expr_set(e, attr, nil, 0)

# --- coercion ------------------------------------------------------

proc rawGetAttr*[T](e: ptr struct_nftnl_expr, attr: uint16): T =
  when T is string:
    $cast[cstring](nftnl_expr_get_str(e, attr))
  elif T is uint8:
    nftnl_expr_get_u8(e, attr)
  elif T is uint16:
    nftnl_expr_get_u16(e, attr)
  elif T is uint32:
    nftnl_expr_get_u32(e, attr)
  elif T is uint64:
    nftnl_expr_get_u64(e, attr)
  elif T is seq[uint8]:
    var size: uint32
    let p = nftnl_expr_get(e, attr, addr size)
    result = @[]
    if not p.isNil and size > 0:
      result.setLen(int(size))
      copyMem(addr result[0], p, size)
  else:
    {.error: "Unsupported type for rawGetAttr".}

proc rawSetAttr*[T](e: ptr struct_nftnl_expr, attr: uint16, v: T) =
  when T is string:
    rawSetAttr(e, attr, v)
  elif T is seq[uint8]:
    rawSetAttr(e, attr, v)
  elif T is SomeInteger:
    when sizeof(T) == 1:
      rawSetAttr(e, attr, v.uint8)
    elif sizeof(T) == 2:
      rawSetAttr(e, attr, v.uint16)
    elif sizeof(T) == 4:
      rawSetAttr(e, attr, v.uint32)
    elif sizeof(T) == 8:
      rawSetAttr(e, attr, v.uint64)
    else:
      {.error: "Unsupported integer size for rawSetAttr".}
  else:
    {.error: "Unsupported type for rawSetAttr".}

# --- macro sugar ------------------------------------------------------

macro attrOp*(
    e: Expression, exprKind: static[string], attr: untyped, args: varargs[untyped]
): untyped =
  ## `exprKind` is a static string like "cmp", "payload", etc.
  ## It selects which contract's expectedType() to use.
  if args.len == 0:
    result = quote:
      rawGetAttr[expectedType(`exprKind`, `attr`)](`e`.raw, `attr`.uint16)
  elif args.len == 1:
    let arg0 = args[0]
    result = quote:
      rawSetAttr[expectedType(`exprKind`, `attr`)](`e`.raw, `attr`.uint16, `arg0`)
  else:
    error("attrOp takes 0 or 1 extra arguments")

# --- convenience wrappers ------------------------------------------------------

template setAttrCmp*(e: Expression, attr: int, val: untyped): untyped =
  attrOp(e, "cmp", attr, val)

template getAttrCmp*(e: Expression, attr: int): untyped =
  attrOp(e, "cmp", attr)
