import ../raii/basics
import ../attrs/ruleAttrsCoersion
import ../autogenerated/generated_nftnl
import ../contracts/rule
import ../raii/basics # for move and `addExpr`

## ---------------------------------------------------------------------------
## Rule properties + sugar layer
## ---------------------------------------------------------------------------

template defRuleProp(attr: static enum_nftnl_rule_attr, propName: untyped) =
  proc propName*(r: Rule): expectedType(attr) =
    ## Property getter
    r.getAttr(attr)

  proc `propName=`*(r: Rule, v: expectedType(attr)) =
    ## Property setter
    r.setAttr(attr, v)

# --- String properties ---
defRuleProp(NFTNL_RULE_TABLE, table)
defRuleProp(NFTNL_RULE_CHAIN, chain)
defRuleProp(NFTNL_RULE_USERDATA, userdata)

# --- uint32 properties ---
defRuleProp(NFTNL_RULE_FAMILY, family)

# --- uint64 properties ---
defRuleProp(NFTNL_RULE_HANDLE, handle)

## ---------------------------------------------------------------------------
## Rule sugar constructors and helpers
## ---------------------------------------------------------------------------

template newRule*(family: int, table, chain: string): Rule =
  ## High-level constructor for a new Rule bound to a table/chain.
  var r = Rule.create()
  r.family = family
  r.table = table
  r.chain = chain
  r

template moveRule*(r: Rule): Rule =
  ## Explicit move sugar (optional).
  move r

## ---------------------------------------------------------------------------
## Expression handling sugar
## ---------------------------------------------------------------------------

template add*(r: var Rule, e: Expression) =
  ## Sugar: safely move an Expression into the Rule (transfers ownership).
  ## This prevents accidental double-free and eliminates the need for explicit `move` in user code.
  addExpr(r, move e)

template add*(r: var Rule, kind: string): Expression =
  ## Convenience: create and add an Expression by kind name (e.g. "cmp", "payload").
  var e = Expression.create(kind)
  addExpr(r, move e)
  e
